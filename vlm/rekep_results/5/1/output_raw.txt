In this task, "reorient the pen and drop it into a holder", there are three stages:
1. Grasp the pen.
2. Reorient the pen to be upright (parallel to the z-axis).
3. Drop the pen into the black holder.

num_stages = 3

### stage 1 sub-goal constraints (grasp the pen)
def stage1_subgoal_constraint1(end_effector, keypoints):
    """Align the end-effector with the pen keypoint."""
    pen_keypoint = keypoints[0]
    cost = np.linalg.norm(end_effector - pen_keypoint)
    return cost

### stage 1 path constraints
# No path constraints needed for this stage.

### stage 2 sub-goal constraints (reorient the pen)
def stage2_subgoal_constraint1(end_effector, keypoints):
    """The pen should be upright (parallel to the z-axis)."""
    pen_base = keypoints[0]
    pen_tip = keypoints[4]
    z_axis = np.array([0, 0, 1])
    pen_vector = pen_tip - pen_base
    cos_theta = np.dot(pen_vector, z_axis) / (np.linalg.norm(pen_vector) * np.linalg.norm(z_axis))
    cost = np.abs(cos_theta - 1)
    return cost

### stage 2 path constraints
def stage2_path_constraint1(end_effector, keypoints):
    """The robot must still be grasping the pen."""
    return get_grasping_cost_by_keypoint_idx(0)

### stage 3 sub-goal constraints (drop the pen into the holder)
def stage3_subgoal_constraint1(end_effector, keypoints):
    """The pen should be 150mm above the holder opening."""
    holder_center = keypoints[1]
    pen_tip = keypoints[4]
    target_height = 150
    offsetted_point = holder_center + np.array([0, 0, target_height])
    cost = np.linalg.norm(pen_tip - offsetted_point)
    return cost

### stage 3 path constraints
def stage3_path_constraint1(end_effector, keypoints):
    """The pen must still stay upright (parallel to the z-axis)."""
    pen_base = keypoints[0]
    pen_tip = keypoints[4]
    z_axis = np.array([0, 0, 1])
    pen_vector = pen_tip - pen_base
    cos_theta = np.dot(pen_vector, z_axis) / (np.linalg.norm(pen_vector) * np.linalg.norm(z_axis))
    cost = np.abs(cos_theta - 1)
    return cost

def stage3_path_constraint2(end_effector, keypoints):
    """The robot must still be grasping the pen."""
    return get_grasping_cost_by_keypoint_idx(0)

"""
Summarize keypoints to be grasped in all grasping stages.
The length of the list should be equal to the number of stages.
For grasping stage, write the keypoint index. For non-grasping stage, write -1.
"""
grasp_keypoints = [0, -1, -1]

"""
Summarize at **the end of which stage** the robot should release the keypoints.
The keypoint indices must appear in an earlier stage as defined in `grasp_keypoints` (i.e., a keypoint can only be released only if it has been grasped previously).
Only release object when it's necessary to complete the task, e.g., drop bouquet in the vase.
The length of the list should be equal to the number of stages.
If a keypoint is to be released at the end of a stage, write the keypoint index at the corresponding location. Otherwise, write -1.
"""
release_keypoints = [-1, -1, 0]